## Explicação da Implementação e Justificativa das Estruturas de Dados

Este projeto simula dois cenários interconectados: um sistema de gerenciamento de grupos sociais onde pessoas se conhecem (Fase 1) e um sistema de gerenciamento de filas de atendimento com regras especiais baseadas nesses grupos (Fase 2). A implementação foi feita em Java, utilizando estruturas de dados apropriadas para cada funcionalidade, visando eficiência e clareza.

### Estrutura Geral do Projeto

O projeto é modularizado para separar as responsabilidades:

1.  **`Simulador.java`**: É a classe principal que orquestra a simulação. Ela é responsável por:
    * Iniciar os serviços de gerenciamento de grupos (`Grupos`) e de filas (`SistemaFilas`).
    * Utilizar a classe `Parser` para ler o arquivo de entrada.
    * Interpretar cada comando lido e delegá-lo à classe apropriada (`Grupos` ou `SistemaFilas`).
    * Coletar e imprimir as saídas geradas pelos comandos.

### Fase 1: Pessoas Conhecem Pessoas (`Grupos.java`)

Esta classe gerencia os grupos de pessoas e as relações de conhecimento entre elas.

* **Objetivo Principal:** Armazenar grupos de pessoas que se conhecem e responder a consultas sobre a existência de pessoas e se duas pessoas se conhecem. A restrição fundamental é que "Uma pessoa não poderá estar em dois grupos diferentes."

* **Estruturas de Dados Utilizadas e Justificativas:**

    1.  `private final Map<String, Set<String>> pessoaParaGrupo;`
        * **O que armazena:** Este mapa associa o nome de uma pessoa (String) a um objeto `Set<String>`. Este `Set` representa o grupo ao qual a pessoa pertence. Crucialmente, todos os membros de um mesmo grupo compartilham a **mesma instância** do objeto `Set`.
        * **Justificativa:**
            * **Eficiência de Acesso:** `HashMap` oferece acesso em tempo médio O(1) para obter o grupo de uma pessoa a partir do seu nome.
            * **Verificação de Conhecimento:** A partilha da mesma instância do `Set` por membros do mesmo grupo torna a verificação `seConhecem(p1, p2)` extremamente eficiente: basta obter os `Set`s de `p1` e `p2` e verificar se são o mesmo objeto (`pessoaParaGrupo.get(p1) == pessoaParaGrupo.get(p2)`). Isso é mais rápido do que comparar o conteúdo dos sets.
            * **Conteúdo do Grupo:** O `Set<String>` interno armazena os nomes dos membros do grupo, garantindo unicidade de nomes dentro daquele grupo específico.

    2.  `private final Set<String> pessoasEmGrupos;`
        * **O que armazena:** Um conjunto (`HashSet`) que contém os nomes de todas as pessoas que já foram atribuídas a algum grupo.
        * **Justificativa:**
            * **Restrição de Unicidade:** Permite verificar de forma eficiente (tempo médio O(1)) se uma pessoa já pertence a algum grupo. Isso é vital para implementar a regra "Uma pessoa não poderá estar em dois grupos diferentes" ao processar o comando `grupo:`. Antes de adicionar uma pessoa a um novo grupo conceitual, o sistema verifica se ela já está neste `Set`. Se estiver, ela não é adicionada ao novo grupo.

* **Lógica dos Comandos:**
    * `grupo: nome [nome1, nome2, ...]`: Ao receber uma lista de nomes para formar um grupo, a implementação primeiro filtra essa lista, considerando apenas os nomes de pessoas que ainda *não* constam em `pessoasEmGrupos`. Com essa lista filtrada (pessoas realmente novas no sistema de grupos), um novo `Set<String>` é criado. Cada uma dessas pessoas novas é então adicionada ao mapa `pessoaParaGrupo` (apontando para esta nova instância de `Set`) e também ao `Set pessoasEmGrupos`.
    * `existe: nome`: Verifica se o `nome` está presente no `Set pessoasEmGrupos`.
    * `conhece: nome1 nome2`: Primeiro, verifica se `nome1` e `nome2` existem (consultando `pessoasEmGrupos`). Se ambos existem, obtém os `Set`s de grupo associados a cada um a partir de `pessoaParaGrupo` e compara se as referências desses `Set`s são idênticas.

### Fase 2: Filas Brasileiras (`SistemaFilas.java`)

Esta classe simula o sistema de múltiplas filas de atendimento, aplicando as regras da "fila brasileira".

* **Objetivo Principal:** Gerenciar a chegada, atendimento e desistência de pessoas em diversas filas (guichês), respeitando a regra de que uma pessoa pode entrar no final da fila ou "furar fila" para ficar junto a um conhecido.

* **Dependência:** Uma instância de `Grupos` é injetada no construtor de `SistemaFilas` para permitir que a lógica de `chegou` consulte se duas pessoas se conhecem.

* **Estruturas de Dados Utilizadas e Justificativas:**

    1.  `private final Map<String, LinkedList<String>> guiches;`
        * **O que armazena:** Este mapa associa o identificador (ID) de um guichê (String) a uma `LinkedList<String>` que representa a fila de pessoas (seus nomes) naquele guichê.
        * **Justificativa:**
            * **`TreeMap`:** Foi escolhido especificamente para o mapa `guiches`. Um `TreeMap` mantém suas chaves (os IDs dos guichês) ordenadas lexicograficamente. Isso garante que, ao executar o comando `imprime:`, as filas sejam listadas sempre na mesma ordem (ordenadas pelo ID do guichê), o que é importante para saídas consistentes e testáveis, conforme implícito nos exemplos.
            * **`LinkedList<String>`:** É a estrutura de dados ideal para filas por várias razões:
                * **Eficiência nas Extremidades:** Permite adição (`addLast()`) e remoção (`removeFirst()`) eficientes de elementos no início e no fim da lista, operações comuns em filas (chegada normal e atendimento).
                * **Inserção Indexada:** Suporta a inserção de elementos em posições arbitrárias (`add(index, element)`). Isso é crucial para a regra da "fila brasileira", onde uma pessoa pode entrar no meio da fila, logo após um conhecido.
                * **Remoção por Valor:** Permite a remoção de um elemento específico pelo seu valor (`remove(Object o)`), útil para o comando `desiste:`.

* **Lógica dos Comandos (método `adicionarPessoaAFila` para `chegou`):**
    O comando `chegou` é o mais complexo e sua lógica é encapsulada principalmente no método `adicionarPessoaAFila`, que é chamado sequencialmente para cada pessoa na lista do comando `chegou`.

    1.  **Prioridade para Conhecidos:**
        * Para a pessoa (`nomePessoa`) que está chegando, o sistema itera sobre todos os guichês (em ordem de ID, devido ao `TreeMap`).
        * Dentro de cada guichê, ele verifica todas as pessoas já na fila para encontrar conhecidos usando `gruposService.seConhecem()`.
        * Se um ou mais conhecidos são encontrados em uma fila, a posição de inserção é determinada como sendo *após o último conhecido encontrado naquela fila específica*. Isso define uma "profundidade" de inserção (o índice onde a pessoa entraria).
        * O sistema compara as profundidades de inserção em todas as filas onde conhecidos foram encontrados. `nomePessoa` será colocada na fila que oferecer a *menor profundidade* (ou seja, o menor índice, o mais próximo do início da fila).
        * **Desempate (Conhecidos):** Se múltiplas filas oferecerem a mesma melhor profundidade para se juntar a um conhecido, a fila com o ID lexicograficamente menor é escolhida (essa preferência ocorre naturalmente devido à ordem de iteração das chaves do `TreeMap`).

    2.  **Sem Conhecidos (Fallback):**
        * Se `nomePessoa` não encontrar nenhum conhecido em nenhuma das filas existentes:
        * Ela é adicionada ao final da fila que estiver *atualmente mais curta*.
        * **Desempate (Sem Conhecidos):** Se múltiplas filas tiverem o mesmo tamanho mínimo, a fila com o ID lexicograficamente menor é escolhida para receber a pessoa (novamente, um resultado natural da iteração ordenada sobre o `TreeMap`).

    Os demais comandos são mais diretos:
    * `criaFila`: Adiciona uma nova chave (ID do guichê) ao `TreeMap guiches` com uma `LinkedList` vazia como valor.
    * `atendeFila`: Para cada ID de guichê especificado, remove o primeiro elemento (`removeFirst()`) da `LinkedList` correspondente, se a fila não estiver vazia.
    * `desiste`: Itera por todas as filas e remove a primeira ocorrência do nome da pessoa especificada de cada `LinkedList` em que for encontrada.
    * `imprime`: Itera sobre as entradas do `TreeMap guiches` (que já estarão ordenadas por ID) e formata a representação de cada fila para a saída.

### Conclusão

A escolha das estruturas de dados (`HashMap`, `HashSet`, `TreeMap`, `LinkedList`) foi guiada pela necessidade de eficiência nas operações mais frequentes de cada fase (busca de pessoas e grupos, manipulação de filas) e pela necessidade de manter uma ordem específica para a saída (no caso do `TreeMap` para os guichês). A lógica implementada busca seguir estritamente as regras e exemplos fornecidos no problema, processando comandos e chegadas de forma sequencial e determinística.